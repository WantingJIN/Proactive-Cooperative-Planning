function [f,f1,f2,f3,f4,f5,w1,w2,w3,w4,w5] = obj_MPC_pro(Con,xr0,xh0,rob,hum,TF,t_fine,t_int) % A start, B final ; X intermediate point
% Objctive function of the optimization problem for one horizon window
% f1: Reach the goal
% f2: Energy consuming
% f3: Human confort
% f4: Directional cost
% f5: Time to collision cost
%------------------------------------------------------------------------------------------------%

%% Cost function
f1 = 0;
f2 = 0;
f3 = 0;
f4 = 0;
f5 = 0;
f=0;
count =1;

xr = xr0;
xh = xh0;
for tspan=0:t_fine:TF-t_fine
     % Update the robot state
    for tsint = 0: t_int: t_fine - t_int
        dx_r = system_model_ROB(Con(count,:),xr);
        xr_new = xr' + dx_r * t_int;
        [dx_h,fir] = system_model_HUMpre_pro(xh,xr,Con(count,:),rob,hum);
        xh_new  = xh' + dx_h * t_int;
        xr = xr_new';
        xh = xh_new';
    end
    
    
    pr = xr(1:2)';
    ph = xh(1:2)';
    vr = [Con(count,1)*cos(xr(3)) Con(count,1)*sin(xr(3))];
    vh = [xh(4)*cos(xh(3)) xh(4)*sin(xh(3))];
    
    
    % Cost function f1: the sum of the distance between the robot current
    % position to the goal position
    % The weight parameter of f1 depends on time, in th beginning the
    % distance to reach the goal is not so important, in the end, the robot
    % should manage to reach the goal
    
    % f1 = f1 + tspan/4*norm(rob.goal - xr(1:2)) ^ 2;
  
    f1 = f1 + norm(rob.goal - xr(1:2)) ^ 2;

    % Cost function f2: the sum of the control input
    f2 = f2 + norm(Con(count,:)) ^ 2;
    
    % Cost function f3: the interaction force of the human generated by the
    % robot
    %     f3 = f3 +norm(fir)+ norm(fiw);
    f3 = f3 + norm(fir);
    
    % Penalty cost function: f4 Direction constriant
    C = norm(pr - ph);
    cdir = (vr*(ph - pr) + vh*(pr -ph))/(C^2);
    if cdir > 1
        f4 = f4 + (cdir - 1)*20;
    else
        f4 = f4;
    end
   
    % Penalty cost function: f5 Time to collision constriant
    fun=@(t)norm(pr + vr' * t - ph - vh' * t)^2;
    
    ttc=8;
    a = norm(vr - vh)^2;
    b = 2 * ((pr(1) - ph(1)) * (vr(1) - vh(1)) + (pr(2) - ph(2)) * (vr(2) - vh(2)));
    
    if 0<-b/(2*a) && -b/(2*a)<ttc
        dist = fun(-b/(2*a));
    else
        dist=min(fun(0),fun(ttc));
    end
    
    if dist < rob.r + hum.r + 2
        f5 = f5 + ( (rob.r + hum.r + 2) - dist)*20;
    else
        f5 = f5;
    end
    

    count = count + 1;
   
end

% f1 = norm(rob.goal - xr(1:2))^2 ;

w1 = 1;
w2 = 1;
w3 = 0.005;
w4 = 5;
w5 = 5;

f1 = w1 * f1; 
f2 = w2 * f2;
f3 = w3 * f3;
f4 = w4 * f4;
f5 = w5 * f5;

w4 = 20*w4;
w5 = 20*w5;

f = f1 + f2 + f3 + f4 +f5;
end